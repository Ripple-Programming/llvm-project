; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=ripple,dce -S < %s | FileCheck %s --implicit-check-not="warning:"

target datalayout = "e-m:e-p:32:32:32-a:0-n16:32-i64:64:64-i32:32:32-i16:16:16-i1:8:8-f32:32:32-f64:64:64-v32:32:32-v64:64:64-v512:512:512-v1024:1024:1024-v2048:2048:2048"

; Function Attrs: nofree norecurse nounwind
define dso_local void @matmult(i32 noundef %N, ptr noalias nocapture noundef readonly %A, ptr noalias nocapture noundef readonly %B, ptr noalias nocapture noundef %C) local_unnamed_addr {
; CHECK-LABEL: @matmult(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP97_NOT:%.*]] = icmp eq i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP97_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_COND1_PREHEADER:%.*]]
; CHECK:       for.cond1.preheader:
; CHECK-NEXT:    [[I_098:%.*]] = phi i32 [ [[INC49:%.*]], [[FOR_COND_CLEANUP28:%.*]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP286:%.*]] = icmp ult i32 32, [[N]]
; CHECK-NEXT:    br i1 [[CMP286]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_COND26_PREHEADER:%.*]]
; CHECK:       for.body3.lr.ph:
; CHECK-NEXT:    [[TMP0:%.*]] = mul nsw i32 [[I_098]], [[N]]
; CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds float, ptr [[C:%.*]], i32 [[TMP0]]
; CHECK-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds float, ptr [[A:%.*]], i32 [[TMP0]]
; CHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.cond26.preheader:
; CHECK-NEXT:    [[J_0_LCSSA:%.*]] = phi i32 [ 0, [[FOR_COND1_PREHEADER]] ], [ [[ADD23:%.*]], [[FOR_COND_CLEANUP9:%.*]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = mul nsw i32 [[I_098]], [[N]]
; CHECK-NEXT:    [[INVARIANT_GEP95:%.*]] = getelementptr float, ptr [[A]], i32 [[TMP1]]
; CHECK-NEXT:    [[ARRAYIDX40:%.*]] = getelementptr inbounds float, ptr [[C]], i32 [[TMP1]]
; CHECK-NEXT:    br label [[FOR_COND30_PREHEADER:%.*]]
; CHECK:       for.body3:
; CHECK-NEXT:    [[J_087:%.*]] = phi i32 [ 0, [[FOR_BODY3_LR_PH]] ], [ [[ADD23]], [[FOR_COND_CLEANUP9]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr float, ptr [[ARRAYIDX4]], i32 [[J_087]]
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr float, ptr [[TMP2]], i32 0
; CHECK-NEXT:    store <32 x float> zeroinitializer, ptr [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[INVARIANT_GEP:%.*]] = getelementptr float, ptr [[B:%.*]], i32 [[J_087]]
; CHECK-NEXT:    br label [[FOR_BODY10:%.*]]
; CHECK:       for.cond.cleanup9:
; CHECK-NEXT:    [[ADD23]] = add i32 32, [[J_087]]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 32, [[ADD23]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[ADD]], [[N]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY3]], label [[FOR_COND26_PREHEADER]]
; CHECK:       for.body10:
; CHECK-NEXT:    [[K_085:%.*]] = phi i32 [ 0, [[FOR_BODY3]] ], [ [[INC:%.*]], [[FOR_BODY10]] ]
; CHECK-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds float, ptr [[ARRAYIDX12]], i32 [[K_085]]
; CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr [[ARRAYIDX13]], align 4
; CHECK-NEXT:    [[DOTRIPPLE_BCAST_SPLATINSERT:%.*]] = insertelement <32 x float> poison, float [[TMP3]], i64 0
; CHECK-NEXT:    [[DOTRIPPLE_BCAST_SPLAT:%.*]] = shufflevector <32 x float> [[DOTRIPPLE_BCAST_SPLATINSERT]], <32 x float> poison, <32 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP4:%.*]] = mul nsw i32 [[K_085]], [[N]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[INVARIANT_GEP]], i32 [[TMP4]]
; CHECK-NEXT:    [[ARRAYIDX17:%.*]] = getelementptr float, ptr [[GEP]], i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = load <32 x float>, ptr [[ARRAYIDX17]], align 4
; CHECK-NEXT:    [[ARRAYIDX21:%.*]] = getelementptr float, ptr [[TMP2]], i32 0
; CHECK-NEXT:    [[TMP6:%.*]] = load <32 x float>, ptr [[ARRAYIDX21]], align 4
; CHECK-NEXT:    [[DOTRIPPLE_VECTORIZED:%.*]] = call <32 x float> @llvm.fmuladd.v32f32(<32 x float> [[DOTRIPPLE_BCAST_SPLAT]], <32 x float> [[TMP5]], <32 x float> [[TMP6]])
; CHECK-NEXT:    store <32 x float> [[DOTRIPPLE_VECTORIZED]], ptr [[ARRAYIDX21]], align 4
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[K_085]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP9]], label [[FOR_BODY10]]
; CHECK:       for.cond30.preheader:
; CHECK-NEXT:    [[K25_094:%.*]] = phi i32 [ 0, [[FOR_COND26_PREHEADER]] ], [ [[INC46:%.*]], [[FOR_INC45:%.*]] ]
; CHECK-NEXT:    [[J_193:%.*]] = phi i32 [ [[J_0_LCSSA]], [[FOR_COND26_PREHEADER]] ], [ [[J_2_LCSSA:%.*]], [[FOR_INC45]] ]
; CHECK-NEXT:    [[CMP3190:%.*]] = icmp ult i32 [[J_193]], [[N]]
; CHECK-NEXT:    br i1 [[CMP3190]], label [[FOR_BODY32_LR_PH:%.*]], label [[FOR_INC45]]
; CHECK:       for.body32.lr.ph:
; CHECK-NEXT:    [[GEP96:%.*]] = getelementptr float, ptr [[INVARIANT_GEP95]], i32 [[K25_094]]
; CHECK-NEXT:    [[TMP7:%.*]] = load float, ptr [[GEP96]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = mul nsw i32 [[K25_094]], [[N]]
; CHECK-NEXT:    [[ARRAYIDX37:%.*]] = getelementptr inbounds float, ptr [[B]], i32 [[TMP8]]
; CHECK-NEXT:    br label [[FOR_BODY32:%.*]]
; CHECK:       for.cond.cleanup28:
; CHECK-NEXT:    [[INC49]] = add nuw i32 [[I_098]], 1
; CHECK-NEXT:    [[EXITCOND101_NOT:%.*]] = icmp eq i32 [[INC49]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND101_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_COND1_PREHEADER]]
; CHECK:       for.body32:
; CHECK-NEXT:    [[J_291:%.*]] = phi i32 [ [[J_193]], [[FOR_BODY32_LR_PH]] ], [ [[INC43:%.*]], [[FOR_BODY32]] ]
; CHECK-NEXT:    [[ARRAYIDX38:%.*]] = getelementptr inbounds float, ptr [[ARRAYIDX37]], i32 [[J_291]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr [[ARRAYIDX38]], align 4
; CHECK-NEXT:    [[ARRAYIDX41:%.*]] = getelementptr inbounds float, ptr [[ARRAYIDX40]], i32 [[J_291]]
; CHECK-NEXT:    [[TMP10:%.*]] = load float, ptr [[ARRAYIDX41]], align 4
; CHECK-NEXT:    [[TMP11:%.*]] = tail call float @llvm.fmuladd.f32(float [[TMP7]], float [[TMP9]], float [[TMP10]])
; CHECK-NEXT:    store float [[TMP11]], ptr [[ARRAYIDX41]], align 4
; CHECK-NEXT:    [[INC43]] = add nuw i32 [[J_291]], 1
; CHECK-NEXT:    [[EXITCOND99_NOT:%.*]] = icmp eq i32 [[INC43]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND99_NOT]], label [[FOR_INC45]], label [[FOR_BODY32]]
; CHECK:       for.inc45:
; CHECK-NEXT:    [[J_2_LCSSA]] = phi i32 [ [[J_193]], [[FOR_COND30_PREHEADER]] ], [ [[N]], [[FOR_BODY32]] ]
; CHECK-NEXT:    [[INC46]] = add nuw nsw i32 [[K25_094]], 1
; CHECK-NEXT:    [[EXITCOND100_NOT:%.*]] = icmp eq i32 [[INC46]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND100_NOT]], label [[FOR_COND_CLEANUP28]], label [[FOR_COND30_PREHEADER]]
;
entry:
  %BS = tail call ptr @llvm.ripple.block.setshape(i32 0, i32 32, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1)
  %cmp97.not = icmp eq i32 %N, 0
  br i1 %cmp97.not, label %for.cond.cleanup, label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.cond.cleanup28
  %i.098 = phi i32 [ %inc49, %for.cond.cleanup28 ], [ 0, %entry ]
  %0 = tail call i32 @llvm.ripple.block.getsize(ptr %BS, i32 0)
  %cmp286 = icmp ult i32 %0, %N
  br i1 %cmp286, label %for.body3.lr.ph, label %for.cond26.preheader

for.body3.lr.ph:                                  ; preds = %for.cond1.preheader
  %1 = mul nsw i32 %i.098, %N
  %arrayidx4 = getelementptr inbounds float, ptr %C, i32 %1
  %arrayidx12 = getelementptr inbounds float, ptr %A, i32 %1
  br label %for.body3

for.cond.cleanup:                                 ; preds = %for.cond.cleanup28, %entry
  ret void

for.cond26.preheader:                             ; preds = %for.cond.cleanup9, %for.cond1.preheader
  %j.0.lcssa = phi i32 [ 0, %for.cond1.preheader ], [ %add23, %for.cond.cleanup9 ]
  %2 = mul nsw i32 %i.098, %N
  %invariant.gep95 = getelementptr float, ptr %A, i32 %2
  %arrayidx40 = getelementptr inbounds float, ptr %C, i32 %2
  br label %for.cond30.preheader

for.body3:                                        ; preds = %for.body3.lr.ph, %for.cond.cleanup9
  %j.087 = phi i32 [ 0, %for.body3.lr.ph ], [ %add23, %for.cond.cleanup9 ]
  %3 = tail call i32 @llvm.ripple.block.index(ptr %BS, i32 0)
  %4 = getelementptr float, ptr %arrayidx4, i32 %j.087
  %arrayidx6 = getelementptr float, ptr %4, i32 %3
  store float 0.000000e+00, ptr %arrayidx6, align 4
  %invariant.gep = getelementptr float, ptr %B, i32 %j.087
  br label %for.body10

for.cond.cleanup9:                                ; preds = %for.body10
  %5 = tail call i32 @llvm.ripple.block.getsize(ptr %BS, i32 0)
  %add23 = add i32 %5, %j.087
  %6 = tail call i32 @llvm.ripple.block.getsize(ptr %BS, i32 0)
  %add = add i32 %6, %add23
  %cmp2 = icmp ult i32 %add, %N
  br i1 %cmp2, label %for.body3, label %for.cond26.preheader

for.body10:                                       ; preds = %for.body3, %for.body10
  %k.085 = phi i32 [ 0, %for.body3 ], [ %inc, %for.body10 ]
  %arrayidx13 = getelementptr inbounds float, ptr %arrayidx12, i32 %k.085
  %7 = load float, ptr %arrayidx13, align 4
  %8 = mul nsw i32 %k.085, %N
  %9 = tail call i32 @llvm.ripple.block.index(ptr %BS, i32 0)
  %gep = getelementptr float, ptr %invariant.gep, i32 %8
  %arrayidx17 = getelementptr float, ptr %gep, i32 %9
  %10 = load float, ptr %arrayidx17, align 4
  %11 = tail call i32 @llvm.ripple.block.index(ptr %BS, i32 0)
  %arrayidx21 = getelementptr float, ptr %4, i32 %11
  %12 = load float, ptr %arrayidx21, align 4
  %13 = tail call float @llvm.fmuladd.f32(float %7, float %10, float %12)
  store float %13, ptr %arrayidx21, align 4
  %inc = add nuw nsw i32 %k.085, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup9, label %for.body10

for.cond30.preheader:                             ; preds = %for.cond26.preheader, %for.inc45
  %k25.094 = phi i32 [ 0, %for.cond26.preheader ], [ %inc46, %for.inc45 ]
  %j.193 = phi i32 [ %j.0.lcssa, %for.cond26.preheader ], [ %j.2.lcssa, %for.inc45 ]
  %cmp3190 = icmp ult i32 %j.193, %N
  br i1 %cmp3190, label %for.body32.lr.ph, label %for.inc45

for.body32.lr.ph:                                 ; preds = %for.cond30.preheader
  %gep96 = getelementptr float, ptr %invariant.gep95, i32 %k25.094
  %14 = load float, ptr %gep96, align 4
  %15 = mul nsw i32 %k25.094, %N
  %arrayidx37 = getelementptr inbounds float, ptr %B, i32 %15
  br label %for.body32

for.cond.cleanup28:                               ; preds = %for.inc45
  %inc49 = add nuw i32 %i.098, 1
  %exitcond101.not = icmp eq i32 %inc49, %N
  br i1 %exitcond101.not, label %for.cond.cleanup, label %for.cond1.preheader

for.body32:                                       ; preds = %for.body32.lr.ph, %for.body32
  %j.291 = phi i32 [ %j.193, %for.body32.lr.ph ], [ %inc43, %for.body32 ]
  %arrayidx38 = getelementptr inbounds float, ptr %arrayidx37, i32 %j.291
  %16 = load float, ptr %arrayidx38, align 4
  %arrayidx41 = getelementptr inbounds float, ptr %arrayidx40, i32 %j.291
  %17 = load float, ptr %arrayidx41, align 4
  %18 = tail call float @llvm.fmuladd.f32(float %14, float %16, float %17)
  store float %18, ptr %arrayidx41, align 4
  %inc43 = add nuw i32 %j.291, 1
  %exitcond99.not = icmp eq i32 %inc43, %N
  br i1 %exitcond99.not, label %for.inc45, label %for.body32

for.inc45:                                        ; preds = %for.body32, %for.cond30.preheader
  %j.2.lcssa = phi i32 [ %j.193, %for.cond30.preheader ], [ %N, %for.body32 ]
  %inc46 = add nuw nsw i32 %k25.094, 1
  %exitcond100.not = icmp eq i32 %inc46, %N
  br i1 %exitcond100.not, label %for.cond.cleanup28, label %for.cond30.preheader
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float)
