; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='module(function(mem2reg,mergereturn),ripple,instcombine,function(dce))' -S %s | FileCheck %s --implicit-check-not="warning:"

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable
define dso_local void @foo(ptr nocapture noundef readonly %A, ptr nocapture noundef writeonly %B) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @foo(
; CHECK-SAME: ptr noundef readonly captures(none) [[A:%.*]], ptr noundef writeonly captures(none) [[B:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[IF_THEN_RIPPLE_VECBRANCH_SUCC_RIPPLE_BRANCH_CLONE:.*]]
; CHECK:       [[IF_ENDRIPPLE_VECBRANCH_SELECTBLOCK:.*]]:
; CHECK-NEXT:    br label %[[IF_END:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[ACC_0_RIPPLE_VECTORIZED_RIPPLE_BCAST:%.*]] = shufflevector <8 x float> [[ACC_0_RIPPLE_VECTORIZED:%.*]], <8 x float> poison, <80 x i32> <i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 4, i32 4, i32 4, i32 4, i32 4, i32 4, i32 4, i32 4, i32 4, i32 4, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5, i32 6, i32 6, i32 6, i32 6, i32 6, i32 6, i32 6, i32 6, i32 6, i32 6, i32 7, i32 7, i32 7, i32 7, i32 7, i32 7, i32 7, i32 7, i32 7, i32 7>
; CHECK-NEXT:    store <80 x float> [[ACC_0_RIPPLE_VECTORIZED_RIPPLE_BCAST]], ptr [[B]], align 4
; CHECK-NEXT:    ret void
; CHECK:       [[IF_THEN_RIPPLE_VECBRANCH_SUCC_RIPPLE_BRANCH_CLONE]]:
; CHECK-NEXT:    br label %[[IF_THEN_RIPPLE_BRANCH_CLONE:.*]]
; CHECK:       [[IF_THEN_RIPPLE_BRANCH_CLONE]]:
; CHECK-NEXT:    [[ARRAYIDX_RIPPLE_LS_INSTANCE1_RIPPLE_BRANCH_CLONE:%.*]] = getelementptr i8, ptr [[A]], <8 x i64> <i64 0, i64 32, i64 64, i64 96, i64 128, i64 160, i64 192, i64 224>
; CHECK-NEXT:    [[ACC_0_RIPPLE_VECTORIZED]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> align 4 [[ARRAYIDX_RIPPLE_LS_INSTANCE1_RIPPLE_BRANCH_CLONE]], <8 x i1> splat (i1 true), <8 x float> poison)
; CHECK-NEXT:    br label %[[IF_END_RIPPLE_PREDSPLIT_RIPPLE_BRANCH_CLONE:.*]]
; CHECK:       [[IF_END_RIPPLE_PREDSPLIT_RIPPLE_BRANCH_CLONE]]:
; CHECK-NEXT:    br label %[[IF_END_RIPPLE_VECBRANCH_SUCC_RIPPLE_BRANCH_CLONE:.*]]
; CHECK:       [[IF_END_RIPPLE_VECBRANCH_SUCC_RIPPLE_BRANCH_CLONE]]:
; CHECK-NEXT:    br label %[[IF_END_RIPPLE_PREDSPLIT_RIPPLE_BRANCH_CLONE2:.*]]
; CHECK:       [[IF_END_RIPPLE_PREDSPLIT_RIPPLE_BRANCH_CLONE2]]:
; CHECK-NEXT:    br label %[[IF_ENDRIPPLE_VECBRANCH_SELECTBLOCK]]
;
entry:
  %BS = tail call ptr @llvm.ripple.block.setshape.i64(i64 0, i64 10, i64 8, i64 1, i64 1, i64 1, i64 1, i64 1, i64 1, i64 1, i64 1)
  %0 = tail call i64 @llvm.ripple.block.index.i64(ptr %BS, i64 0)
  %1 = tail call i64 @llvm.ripple.block.index.i64(ptr %BS, i64 1)
  %cmp = icmp ult i64 %0, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %arrayidx = getelementptr inbounds [8 x float], ptr %A, i64 %1
  %2 = load float, ptr %arrayidx, align 4, !tbaa !5
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %acc.0 = phi float [ %2, %if.then ], [ 0.000000e+00, %entry ]
  %arrayidx3 = getelementptr inbounds [10 x float], ptr %B, i64 %1, i64 %0
  store float %acc.0, ptr %arrayidx3, align 4, !tbaa !5
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)
declare ptr @llvm.ripple.block.setshape.i64(i64 immarg, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64) #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: read)
declare i64 @llvm.ripple.block.index.i64(ptr, i64 immarg) #2

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #2 = { mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: read) }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"Clang $LLVM_VERSION_MAJOR.$LLVM_VERSION_MINOR"}
!5 = !{!6, !6, i64 0}
!6 = !{!"float", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
